import http from 'http';
import fs from 'fs';
import * as dotenv from 'dotenv';
import { URL } from 'url';
dotenv.config();

import IssuerDataFetcher from './lib/IssuerDataFetcher.js';
import TokenRequestCreator from './lib/TokenRequestCreator.js';
import TokenRedemption from './lib/TokenRedemption.js';

// --- 1. CONFIGURATION MAPPING ---
// Map the simple keys from index.html to the real URLs in .env
const ISSUER_MAP = {
    'cf_demo': process.env.ISSUER_CF_DEMO,
    'cf_sat':  process.env.ISSUER_CF_SAT,
    'fastly':  process.env.ISSUER_FASTLY
};

const DEFAULT_ISSUER = process.env.TOKEN_DICT_URL;

const issuerDataFetcher = new IssuerDataFetcher();
const tokenRequestCreator = new TokenRequestCreator();
const tokenRedemption = new TokenRedemption();

if (!DEFAULT_ISSUER) {
    console.error('Error: Please configure .env file with issuer URLs.');
    process.exit(1);
}

http.createServer(async function (req, res) {
    try {
        // --- 2. URL PARSING & DEBUGGING ---
        // We construct the URL object first
        const currentUrl = new URL(req.url, `http://${req.headers.host}`);
        
        // >>> DEBUG CODE START <<<
        console.log('\n------------------------------------------------');
        console.log(`[DEBUG] Incoming Request: ${req.method}`);
        console.log(`[DEBUG] Full URL: ${currentUrl.href}`);
        console.log(`[DEBUG] Pathname: ${currentUrl.pathname}`);
        console.log(`[DEBUG] Query Params:`, Object.fromEntries(currentUrl.searchParams));
        console.log('------------------------------------------------');
        // >>> DEBUG CODE END <<<

        const issuerKey = currentUrl.searchParams.get('issuer');

        // Logic: If user visits root "/" with NO key and NO auth header, show selection screen.
        if (currentUrl.pathname === '/' && !issuerKey && !req.headers['authorization']) {
            console.log('Serving Selection Dashboard (index.html)');
            try {
                let html = fs.readFileSync("html/index.html", "utf8");
                res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
                res.end(html);
                return;
            } catch (e) {
                console.log("index.html missing");
            }
        }

        // --- 3. DETERMINE ISSUER URL ---
        // Lookup the key in our map. If not found, fall back to default.
        let targetIssuerUrl = ISSUER_MAP[issuerKey] || DEFAULT_ISSUER;
        
        console.log(`> Key: "${issuerKey}" | Using URL: ${targetIssuerUrl}`);

        // --- 4. FETCH ISSUER DATA ---
        const issuerInfo = await issuerDataFetcher.fetchIssuerData(targetIssuerUrl);


        // --- 5. VALIDATION LOGIC (CHECK FOR TOKEN) ---
        let validationResult = { isValid: false };
        if ('authorization' in req.headers) {
            validationResult = tokenRedemption.validateAuthToken(issuerInfo, req.headers['authorization']);
        }

        if (validationResult.isValid) {
            // ==========================================
            // CASE 200: SUCCESS - Token Valid
            // ==========================================
            console.log('200 - Authenticated Request');

            let html = fs.readFileSync("html/success200.html", "utf8");
            
            // Inject Display Data
            html = html.replace('AUTH_HEADER', req.headers['authorization']);
            html = html.replace('TOKEN_INFO_JSON', JSON.stringify(validationResult.tokenData, null, 4));

            res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
            res.end(html);

        } else {
            // ==========================================
            // CASE 401: CHALLENGE - Ask for Token
            // ==========================================
            console.log('401 - Sending Challenge for: ' + issuerInfo.issuer_name);

            // Generate the challenge string
            const tokenRequest = tokenRequestCreator.createTokenRequest(
                issuerInfo.issuer_name, 
                process.env.INCLUDE_RANDOM_NONCE || true, 
                process.env.ORIGIN_SCOPE
            );
            
            // Register this request internally so we can verify the response later
            tokenRedemption.registerTokenRequestForRedemption(Buffer.from(tokenRequest, 'base64'));
            
            // Construct the WWW-Authenticate Header
            const challengeString = `PrivateToken challenge=${tokenRequest}, token-key=${issuerInfo.issuer_public_key_base64}`;

            // Prepare the 401 HTML Page
            let html = fs.readFileSync("html/challenge401.html", "utf8");

            // Fill in the placeholders
            html = html.replace('CHALLENGE_STRING_VAL', challengeString);
            html = html.replace('ISSUER_NAME_VAL', issuerInfo.issuer_name);
            html = html.replace('ORIGIN_SCOPE_VAL', process.env.ORIGIN_SCOPE || "N/A");
            html = html.replace('TOKEN_KEY_VAL', issuerInfo.issuer_public_key_base64);

            // Show error if previous attempt failed
            if (validationResult.error) {
                html = html.replace('ERROR_MSG', `<p style="color:red">Validation Failed: ${validationResult.error}</p>`);
            } else {
                html = html.replace('ERROR_MSG', '');
            }

            // Send 401
            res.writeHead(401, { 
                'Content-Type': 'text/html; charset=utf-8',
                'WWW-Authenticate': challengeString 
            });
            res.end(html);
        }

    } catch (error) {
        console.error("Critical Server Error:", error);
        res.writeHead(500);
        res.end("Internal Server Error");
    }

}).listen(process.env.NODE_PORT || 8080);

console.log(`Server started on port ${process.env.NODE_PORT || 8080}`);
